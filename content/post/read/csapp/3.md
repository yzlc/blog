---
title: "第3章 程序的机器级表示"
date: 2019-12-31T10:32:33+08:00
tags: [csapp]
categories: [阅读]
draft: false
---

## 3.2 程序编码
### 3.2.1 机器级代码
- 程序计数器（PC，在x86-64中用%rip表示）：给出要执行的下一条指令在内存中的地址
- 整数寄存器：包含16个命名位置，分别存储64位值。可以存储地址或整数。有的寄存器用来记录程序状态，其他的保存临时数据
- 条件码寄存器：保存最近执行的算术或逻辑指令状态。用来实现控制或数据流中的条件变化
- 一组向量寄存器可以存放一个或多个整数或浮点数
- 程序内存（虚拟地址寻址）：
  - 程序的可执行机器代码
  - 操作系统需要的信息
  - 用来管理过程调用和返回的运行时栈
  - 用户分配的内存块
### 3.2.2 代码示例
- 机器代码和它的反汇编表示的特性
  - x86-64指令长度1-15字节不等。常用指令及操作数较少的指令所需字节数少
  - 设计指令格式的方式：从某个给定位置开始，可以将字节唯一地解码成机器指令

## 3.3 数据格式
| C声明  | Intel数据类型    | 汇编代码后缀 | 大小(字节) |
| ------ | ---------------- | ------------ | ---------- |
| char   | 字节             | b            | 1          |
| short  | 字(word)         | w            | 2          |
| int    | 双字(long word)  | l            | 4          |
| long   | 四字(quad words) | q            | 8          |
| char-  | 四字             | q            | 8          |
| float  | 单精度           | s            | 4          |
| double | 双精度           | l            | 8          |
- 任何指针都是8字节

## 3.4 访问信息
### 3.4.1 操作数指示符
- 立即数(immediate)：
  - 语法：$Imm
  - 操作数值：Imm(常数)
- 寄存器(register)：
  - 语法：$r_a$
  - 操作数值：$R[r_a]$
- 内存引用
  - 语法：$Imm(r_b,r_i,s)$
  - Imm：立即数偏移
  - $r_b$：基址寄存器
  - $r_i$：变址寄存器
  - s：比例因子，必须是1、2、4、8
  - 操作数值：$M[Imm+R[r_b]+R[r_i]·s]$
### 3.4.2 数据传送指令
- 两个操作数不能都指向内存$Imm(r_b,r_i,s)$位置
- 后缀大小与内存部分无关
- MOV(S,D)：
  - S(源)：立即数，存储在寄存器/内存
  - D(目的位置)：寄存器/内存地址
  - movl(S——>寄存器)：把该寄存器的高位4字节设置为0
  - movabsq(绝对)：(S(64位)——>D(寄存器))
- MOVZ(S(小),R(大))：R<——零扩展(S)
- MOVS(S(小),R(大))：R<——符号扩展(S)
  - cltq：只用于寄存器%eax和%rax
### 3.4.4 压入和弹出栈数据
- pushq：入栈，指针-8
- popq：出栈，指针+8

## 3.5 算术和逻辑操作
| 指令      | 效果           | 描述              |
| --------- | -------------- | ----------------- |
| leaq S，D | D <—— &S       | 加载有效地址      |
| INC D     | D <—— D+1      | 加1               |
| DEC D     | D <—— D-1      | 减l               |
| NEG D     | D <—— -D       | 取负              |
| NOT D     | D <—— ~D       | 取补              |
| ADD S，D  | D <—— D+S      | 加                |
| SUB S，D  | D <—— D-S      | 减                |
| IMUL S，D | D <—— D*S      | 乘                |
| XOR S，D  | D <—— D^S      | 异或              |
| OR S，D   | D <—— D\|S     | 或                |
| AND S，D  | D <—— D&S      | 与                |
| SAL K，D  | D <—— D<<K     | 左移              |
| SHL K，D  | D <—— D<<K     | 左移（等同于SAL） |
| SAR K，D  | D <—— D>>$_A$K | 算术右移          |
| SHR K，D  | D <—— D>>$_L$K | 逻辑右移          |
### 3.5.1 加载有效地址
>leaq（load effective address），movq的变形
- 可以执行加法和有限乘法
### 3.5.5 特殊的算术操作
| 指令    | 效果                                 | 描述         |
| ------- | ------------------------------------ | ------------ |
| imulq S | R[%rdx]：R[%rax]<——S*R[%rax]         | 有符号全乘法 |
| mulq S  | R[%rdx]：R[%rax]<——S*R[%rax]         | 无符号全乘法 |
| clto    | R[%rdx]：R[%rax]<——符号扩展(R[%rax]) | 转换为八字   |
| idivq S | R[%rdx]<——R[%rdx]：R[%rax] mod/÷ S   | 有符号除法   |
| divq S  | R[%rdx]<——R[%rdx]：R[%rax] mod/÷ S   | 无符号除法   |

## 3.6 控制
### 3.6.1 条件码
- CF：进位。无符号溢出
- ZF：零
- SF：符号。负数
- OF：溢出。补码溢出

| 指令        | 基于  | 描述 |
| ----------- | ----- | ---- |
| CMP S1，S2  | S2-S1 | 比较 |
| TEST S1，S2 | S1&S2 | 测试 |
### 3.6.2 访问条件码
| 指令    | 同义名 | 效果             | 设置条件             |
| ------- | ------ | ---------------- | -------------------- |
| sete D  | setz   | D<——ZF           | 相等/零              |
| setne D | setnz  | D<——~ZF          | 不等/非零            |
| sets D  |        | D<——SF           | 负数                 |
| setns D |        | D<——~SF          | 非负数               |
| setg D  | setnle | D<——~(SF^OF)&~ZF | 大于(有符号>)        |
| setge D | setnl  | D<——~(SF^OF)     | 大于等于(有符号>=)   |
| setl D  | setnge | D<——SF^OF        | 小于(有符号<)        |
| setle D | setng  | D<——(SF^OF)\|ZF  | 小于等于(有符号<=)   |
| seta D  | setnbe | D<——~CF&~ZF      | 超过(无符号>)        |
| setae D | setnb  | D<——~CF          | 超过或相等(无符号>=) |
| setb D  | setnae | D<——CF           | 低于(无符号<)        |
| setbe D | setna  | D<——CF\|ZF       | 低于或相等(无符号<=) |
### 3.6.3 跳转指令
| 指令         | 同义名 | 跳转条件     | 描述                 |
| ------------ | ------ | ------------ | -------------------- |
| jmp Label    |        | 1            | 直接跳转             |
| jmp *Operand |        | 1            | 间接跳转             |
| je Label     | jz     | ZF           | 相等/零              |
| jne Label    | jnz    | ~ZF          | 不相等/非零          |
| js Label     |        | SF           | 负数                 |
| jns Label    |        | ~SF          | 非负数               |
| jg Label     | jnle   | ~(SF^OF)&~ZF | 大于(有符号>)        |
| jge Label    | jnl    | ~(SF^OF)     | 大于等于(有符号>=)   |
| jl Label     | jnge   | ~SF^OF       | 小于(有符号<)        |
| jle Label    | jng    | (SF^OF)      | 小于等于(有符号<=)   |
| ja Label     | jnbe   | ~CF&~ZF      | 超过(无符号>)        |
| jae Label    | jnb    | ~CF          | 超过或相等(无符号>=) |
| jb Label     | jnae   | CF           | 低于(无符号<)        |
| jbe Label    | jna    | CF\|ZF       | 低于或相等(无符号<=) |
### 3.6.4 跳转指令的编码
- PC-relative：将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码
### 3.6.5 用条件控制来实现条件分支
C：
```c
if(test-expr)
    then-statement
else
    else-statement
```
汇编：
```
    t = test-expr;
    if(!t)
        goto false;
    then-statement
    goto done;
false:
    else-statement
done:
```
### 3.6.6 用条件传送来实现条件分支
- 使用控制(低效)：条件满足时，沿着一条路径执行，不满足时走另一条路径
- 使用数据(受限)：计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个
### 3.6.7 循环
1. do-while
    C：
    ```c
    do
        body-statement
        while(test-expr);
    ```
    汇编：
    ```
    loop:
        body-statement
        t = test-expr;
        if(t)
            goto loop;
    ```
2. while
    C：
    ```c
    while(test-expr)
            body-statement
    ```
    汇编：
    方法1：跳转到中间
    ```
        goto test;
    loop:
        body-statement
    test:
        t = test-expr;
        if(t)
            goto loop;
    ```
    方法2(较高优化等级编译时)：guarded-do(先判断再做do-while)
    ```
    t = test-expr;
    if(!t)
        goto done;
    loop:
        body-statement
        t = test-expr;
        if(t)
            goto loop;
    done;
    ```
3. for
    C：
    ```c
    for(init-expr;test-expr;update-expr)
        body-statement
    ```
    汇编：
    方法1：跳转到中间
    ```
    init-expr
    goto test;
    loop:
        body-statement
        update-expr
    test:
        t = test-expr;
        if(t)
            goto loop;
    ```
    方法2(较高优化等级编译时)：guarded-do(先判断再做do-while)
    ```
    init-expr
    t = test-expr;
    if(!t)
        goto done;
    loop:
        body-statement
        update-expr;
        t = test-expr;
        if(t)
            goto loop;
    done;
    ```
### 3.6.8 switch语句
>根据一个整数索引值进行多重分支
- 跳转表(开关数量多，值范围小)：执行开关语句的时间与开关情况的数量无关

## 3.7 过程
### 3.7.1 运行时栈
- x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素。减小栈指针分配空间，增加栈指针释放空间
- 当x86-64过程需要的存储空间超出寄存器存放大小，就会在栈上分配空间（栈帧）
- 许多函数不需要栈帧（所有局部变量都保存在寄存器，不调用其他函数）（树结构中的叶子过程）
### 3.7.2 转移控制
P->Q：call push A（P指令后的地址），PC设为Q；ret pop A，把PC设为A

| 指令          | 描述             |
| ------------- | ---------------- |
| call Label    | 过程调用         |
| call *Operand | 过程调用         |
| ret           | 从过程调用中返回 |
### 3.7.3 数据传送
x86-64中，寄存器最多传递6个整型参数，超过部分栈传递

| 操作数大小（位） | 参数数量1 | 2    | 3    | 4    | 5    | 6    |
| ---------------- | --------- | ---- | ---- | ---- | ---- | ---- |
| 64               | %rdi      | %rsi | %rdx | %rcx | %r8  | %r9  |
| 32               | %edi      | %esi | %edx | %ecx | %r8d | %r9d |
| 16               | %di       | %si  | %dx  | %cx  | %r8w | %r9w |
| 8                | %dil      | %sil | %dl  | %cl  | %r8b | %r9b |
### 3.7.4 栈上的局部存储
- 局部数据必须存放在内存的情况
  - 寄存器不够存放所有本地数据
  - 对局部变量使用地址运算符‘&’，因此必须能够为它产生一个地址
  - 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到
### 3.7.5 寄存器中的局部存储空间
- 寄存器组是唯一被所有过程共享的资源
- 被调用者保存寄存器：%rbx、%rbp和%r12~%r15
- 调用者保存寄存器：除了栈指针%rsp
### 3.7.6 递归过程

## 3.8 数组分配和访问
### 3.8.1 基本原则
T A[N]
  - L：T的大小（字节）
  - A：数组开头指针，值为$x_A$
  - 元素i：存放在地址为$x_A+L·i$的地方
### 3.8.2 指针运算
- &：指针
- *：间接引用指针（值）
- Expr与- &Expr等价
### 3.8.3 嵌套的数组
- 数组元素在内存中按照“行优先”的顺序排列
- T D[R][C]
  - D[i][j]的内存地址：&D[i][j] = $x_D$+L(C·i+j)
  - L：数据类型T大小（字节）
### 3.8.4 定长数组
### 3.8.5 变长数组

## 3.9 异质的数据结构
### 3.9.1 结构
### 3.9.2 联合
### 3.9.3 数据对齐

## 3.10 在机器级程序中将控制与数据结合起来
### 3.10.1 理解指针
- 每个指针都对应一个类型。例：
  - `int *ip`：int类型指针
  - `char **cpp`：char*类型指针
- 每个指针都有一个值(类型对象的地址)。NULL(0)值表示没指向任何地方
- 指针用`&`运算符创建
  - lvalue：可以出现在赋值语句左边的表达式
  - 这个运算符可以应用到lvalue类的C表达式上
  - 机器代码常常用leaq指令(计算内存引用地址)实现
- `*`操作符用于间接引用指针
  - 结果是一个值
  - 用内存引用实现：要么是存储到指定地址，要么是从指定地址读取
- 数组与指针紧密联系
  - 数组名字可以像指针变量一样引用但不能修改
  - 数组引用(`a[3]`)与指针运算和间接引用(`*(a + 3)`)有一样的效果
    - 数组引用和指针运算都需要用对象大小对偏移量进行伸缩
    - 当我们写表达式p + i,这里指针p的值为$p$,得到的地址计算为$p+L·i$，$L$是与p相关联的数据类型的大小
- 指针也可以指向函数(值是该函数机器代码表示中第一条指令的地址)
  1. 定义函数：  
     `int fun(int x,int *p);`
  2. 声明指针并赋值：
        ```c
        int (*fp)(int,int *);//括号是必须的，防止被解读成(int *) fp(int,int *);
        fp = fun;
        ```
  3. 调用：
        ```c
        int y = 1;
        int result = fp(3,&y);
        ```
### 3.10.2 应用：使用GDB调试器
### 3.10.3 内存越界引用和缓冲区溢出
