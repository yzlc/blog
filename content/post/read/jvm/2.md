---
title: "第2章　Java内存区域与内存溢出异常"
date: 2020-05-08T10:32:33+08:00
tags: [jvm]
categories: [阅读]
draft: false
hiddenFromHomePage: true
---

## 2.2　运行时数据区域
![](/images/read/jvm/2-1.png)
### 2.2.1　程序计数器（Program Counter Register）
>较小内存空间，可以看作是当前线程所执行的字节码的行号指示器。  
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。  
程序控制流的指示器:分支、循环、跳转、异常处理、线程恢复等。

- 执行Java方法:记录虚拟机字节码指令地址
- 执行本地（Native）方法:值为空（Undefined）
- 此内存区域是唯一一个在《Java虚拟机规范》中没有规定OutOfMemoryError的区域
### 2.2.2　Java虚拟机栈（Java Virtual Machine Stack）
>线程私有的，生命周期与线程相同。
描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。  
每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

- StackOverflow:线程请求的栈深度 > 虚拟机允许的深度
- OutOfMemory:如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时

#### 局部变量表
>存放编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。  
存储空间以局部变量槽（Slot）来表示:64位的long和double占用两个变量槽，其余的数据类型只占用一个。  
所需的内存空间在编译期间完成分配:进入方法时，需要在栈帧中分配的局部变量空间是确定的，方法运行期间不会改变局部变量表的大小(变量槽的数量)。

### 2.2.3　本地方法栈（Native Method Stacks）
>与虚拟机栈作用相似  
区别:虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，
本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

### 2.2.4　Java堆（Java Heap）
>虚拟机所管理的内存中最大的一块。线程共享，在虚拟机启动时创建。  
几乎所有的对象实例都在这里分配内存。  
Java堆是垃圾收集器管理的内存区域，因此也被称作“GC堆”（Garbage Collected Heap）。

- OutOfMemory:没有内存完成实例分配，并且堆也无法再扩展

### 2.2.5　方法区（Method Area）
>线程共享,用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

- OutOfMemory:方法区无法满足新的内存分配需求

### 2.2.6　运行时常量池（Runtime Constant Pool）
>方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

- vs Class文件常量池
  - Class文件每一部分的格式都有严格规定,运行时常量池《Java虚拟机规范》并没有做任何细节的要求，一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中 。

  - 运行时常量池具备动态性，运行期间可以将新的常量放入池中，例如String类的intern()方法。

- OutOfMemory:常量池无法再申请到内存

### 2.2.7　直接内存（Direct Memory）
>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区
（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的
DirectByteBuffer对象作为这块内存的引用进行操作。

- 能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

- OutOfMemory:忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现

## 2.3　HotSpot虚拟机对象探秘
### 2.3.1　对象的创建
new -> 检查常量池中类是否已被加载 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行构造函数

- 内存分配(由堆是否规整决定)
  - 指针碰撞（Bump The Pointer）:内存规整,使用的放一边，空闲的放一边，中间放指针作为分界点的指示器，分配内存就是把那个指针向空闲空间方向挪动与对象大小相等的距离
  - 空闲列表（Free List）:内存不规整,维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

- 堆是否规整(由垃圾收集器是否带有空间压缩整理（Compact）决定)
  - 使用Serial、ParNew等带压缩整理
  - 使用CMS基于清除（Sweep）算法的收集器

- 本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）:每个线程在Java堆中预先分配一小块内存,通过-XX：+/-UseTLAB参数设定

- 线程安全
  - 同步处理:CAS配上失败重试的方式保证更新操作的原子性
  - 按线程划分在不同的空间之中进行:TLAB，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定

- 对象头（Object Header）:对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（真正调hashCode()时计算）、对象的GC分代年龄等

### 2.3.2　对象的内存布局
>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
#### 对象头
>Mark Word和类型指针

- Mark Word(存储对象自身的运行时数据):有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间,长度（未开启压缩指针）为32个比特(32位)和64个比特(64位)
  - 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态下对象的存储内容如下表所示。
    | 存储内容                             | 标志 | 状态             |
    | ------------------------------------ | ---- | ---------------- |
    | 对象哈希码、对象分代年龄             | 01   | 未锁定           |
    | 指向锁记录的指针                     | 00   | 轻量级锁定       |
    | 指向重量级锁的指针                   | 10   | 膨胀(重量级锁定) |
    | 空,不需要记录信息                    | 11   | GC标记           |
    | 偏向线程ID、偏向时间戳、对象分代年龄 | 01   | 可偏向           |

  - HotSpot 虚拟机(32位)代表Mark Word中的代码（markOop.cpp）注释片段：
    ```c
    // Bit-format of an object header (most significant first, big endian layout below):
    //
    // 32 bits:
    // --------
    // hash:25 ------------>| age:4 biased_lock:1 lock:2 (normal object)
    // JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object)
    // size:32 ------------------------------------------>| (CMS free block)
    // PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
    ```

- 类型指针: 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。
  - 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。
  - 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据:因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

#### 实例数据
>对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。
- 存储顺序:受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary
Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存
放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的
+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空
隙之中，以节省出一点点空间。

#### 对齐填充
>占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

### 2.3.3　对象的访问定位
>通过栈上的reference数据来操作堆上的具体对象

- 句柄:Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图2-2所示。
![](/images/read/jvm/2-2.png)
  - 好处: reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而
reference本身不需要被修改。

- 直接指针:Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关
信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问
的开销，如图2-3所示。
![](/images/read/jvm/2-3.png)
  - 好处: 速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本