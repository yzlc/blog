---
title: "第2章　Java内存区域与内存溢出异常"
date: 2020-05-08T10:32:33+08:00
tags: [jvm]
categories: [阅读]
hiddenFromHomePage: true
---

## 2.2　运行时数据区域
![](/images/read/jvm/2-1.jpg)
### 2.2.1　程序计数器（Program Counter Register）
>字节码的行号指示器，程序控制流的指示器（分支、循环、跳转、异常处理、线程恢复等）

记录内容
- 执行Java方法：记录虚拟机字节码指令地址
- 执行本地（Native）方法：值为空（Undefined）

异常情况
- 唯一一个没有规定OutOfMemoryError的区域
### 2.2.2　Java虚拟机栈（Java Virtual Machine Stack）
>Java方法执行的线程内存模型：方法被执行的时候，同步创建一个栈帧（Stack Frame）（存储局部变量表、操作数栈、动态连接、方法出口等信息）。方法执行过程对应栈帧从入栈到出栈的过程

异常情况
- StackOverflow：线程请求的栈深度 > 虚拟机允许的深度  
- OutOfMemory：栈扩展无法申请到足够的内存时

局部变量表
>存放基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）
- 存储空间
  - 局部变量槽（Slot）：64位的long和double占用两个变量槽，其余的数据类型只占用一个
- 内存分配
  - 在编译期完成分配：进入方法时，需要在栈帧中分配的局部变量空间是确定的，方法运行期间不会改变局部变量表的大小(变量槽的数量)

### 2.2.3　本地方法栈（Native Method Stacks）
>为虚拟机使用到的本地（Native）方法服务

### 2.2.4　Java堆（Java Heap）
>在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存。垃圾收集器管理的内存区域（GC堆（Garbage Collected Heap））

异常情况
- OutOfMemory：没有内存完成实例分配，并且堆也无法再扩展

### 2.2.5　方法区（Method Area）
>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

异常情况
- OutOfMemory：方法区无法满足新的内存分配需求

### 2.2.6　运行时常量池（Runtime Constant Pool）
>方法区的一部分。Class文件中的常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，类加载后存放到运行时常量池中

对比Class文件常量池
- Class文件的格式有严格规定，运行时常量池没有做任何细节的要求（一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中）
- 运行时常量池具备动态性，运行期间可以将新的常量放入池中，例如String类的intern()方法

异常情况
- OutOfMemory：常量池无法再申请到内存

### 2.2.7　直接内存（Direct Memory）
>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。使用Native函数库直接分配堆外内存，通过存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作

特点
- 能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据

异常情况
- OutOfMemory：忽略直接内存，使得各个内存区域总和大于物理内存限制，导致动态扩展

## 2.3　HotSpot虚拟机对象探秘
### 2.3.1　对象的创建
>new -> 检查常量池中类是否已被加载 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行构造函数

内存分配方式(由堆是否规整决定)
- 指针碰撞（Bump The Pointer）：内存规整，使用的放一边，空闲的放一边，中间放指针作为分界点的指示器，分配内存就是把那个指针向空闲空间方向挪动与对象大小相等的距离
- 空闲列表（Free List）：内存不规整，维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

堆是否规整
- 使用Serial、ParNew等带压缩整理（Compact）
- 使用CMS基于清除（Sweep）算法的收集器

线程安全
- 同步处理：CAS配上失败重试的方式保证更新操作的原子性
- 按线程划分在不同的空间之中进行：TLAB，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定
  - 本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：每个线程在Java堆中预先分配一小块内存

对象头（Object Header）：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（真正调hashCode()时计算）、对象的GC分代年龄等

### 2.3.2　对象的内存布局
>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）

对象头
- Mark Word：存储对象自身的运行时数据，有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间，长度为32个比特(32位)和64个比特(64位)

  | 存储内容                             | 标志 | 状态             |
  | ------------------------------------ | ---- | ---------------- |
  | 对象哈希码、对象分代年龄             | 01   | 未锁定           |
  | 指向锁记录的指针                     | 00   | 轻量级锁定       |
  | 指向重量级锁的指针                   | 10   | 膨胀(重量级锁定) |
  | 空,不需要记录信息                    | 11   | GC标记           |
  | 偏向线程ID、偏向时间戳、对象分代年龄 | 01   | 可偏向           |

- 类型指针：对象指向它的类型元数据的指针，通过指针来确定对象是哪个类的实例
  - 不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身
  - 数组在对象头中必须有一块用于记录数组长度的数据：元数据信息可以确定Java对象的大小，但如果数组的长度是不确定的，无法通过元数据中的信息推断出数组的大小

实例数据：对象真正存储的有效信息，代码中各种类型的字段内容，无论父类继承还是子类定义的字段都记录起来

对齐填充：占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍

### 2.3.3　对象的访问定位
>通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有句柄和直接指针两种

句柄：划分出一块内存来作为句柄池，reference中存储的对象的句柄地址，句柄中包含对象实例数据与类型数据各自具体的地址信息
![](/images/read/jvm/2-2.jpg "通过句柄访问对象")
  - 好处： reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改

直接指针：必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，只访问对象本身的话，就不需要多一次间接访问的开销
![](/images/read/jvm/2-3.jpg "通过直接指针访问对象")
  - 好处： 速度更快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本