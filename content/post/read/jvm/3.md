---
title: "第3章　垃圾收集器与内存分配策略"
date: 2020-05-08T10:32:33+08:00
tags: [jvm]
categories: [阅读]
draft: false
hiddenFromHomePage: true
---

## 3.2　对象已死？
### 3.2.1　引用计数算法
>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
### 3.2.2　可达性分析算法
>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的
![](/images/read/jvm/3-1.png)
- GC Roots
  - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
  - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
  - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
  - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
  - 所有被同步锁（synchronized关键字）持有的对象。
  - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
### 3.2.3　再谈引用
- 强引用（Strongly Re-ference）: 指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用（Soft Reference）: 还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常
- 弱引用（Weak Reference）: 非必须对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- 虚引用（Phantom Reference）: 最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
### 3.2.4　生存还是死亡？
可达性分析 -> 标记 -> F-Queue队列,由Finalizer线程执行finalize() -> 标记 -> 回收
### 3.2.5　回收方法区
>废弃的常量和不再使用的类型
- 废弃常量: 回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

- 不再使用的类型
  - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
  - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

- HotSpot虚拟机提供了-Xnoclassgc参数进行控制
- 查看类加载和卸载信息
  - Product版: -verbose：class和-XX：+TraceClassLoading
  - FastDebug版: -XX：+TraceClassUnLoading
- 场景: 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 3.3　垃圾收集算法
>引用计数式垃圾收集（ReferenceCounting GC）和追踪式垃圾收集（Tracing GC）
### 3.3.1　分代收集理论（Generational Collection）
>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。  
2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。  
3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极
少数。
### 3.3.2　标记-清除算法（Mark-Sweep）
>标记出所有需要回收的对象，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象
- 执行效率不稳定: 标记和清除两个过程的执行效率都随对象数量增长而降低
- 内存空间碎片化: 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
![](/images/read/jvm/3-2.png)
### 3.3.3　标记-复制算法
- 半区复制（Semispace Copying），将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![](/images/read/jvm/3-3.png)
  - 可用内存缩小为了原来的一半，空间浪费多
- Appel式回收: 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间
  - 逃生门: 当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）
### 3.3.4　标记-整理算法

