---
title: "第3章　内存分配策略"
date: 2020-05-09T10:32:33+08:00
tags: [jvm]
categories: [阅读]
---

## 3.2　对象已死？
### 3.2.1　引用计数算法
>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
### 3.2.2　可达性分析算法
>通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的

![](/images/read/jvm/3-1.jpg)
GC Roots
- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
### 3.2.3　再谈引用
强引用（Strongly Re-ference）：普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象

软引用（Soft Reference）：还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常

弱引用（Weak Reference）：非必须对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象

虚引用（Phantom Reference）：最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
### 3.2.4　生存还是死亡？
>可达性分析 -> 标记 -> F-Queue队列,由Finalizer线程执行finalize() -> 标记 -> 回收
### 3.2.5　回收方法区
>废弃的常量和不再使用的类型，垃圾收集的性价比比较低

废弃常量：没有任何对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量

不再使用的类型
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的
- 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

需求场景：在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力

## 3.3　垃圾收集算法
>引用计数式垃圾收集（ReferenceCounting GC）和追踪式垃圾收集（Tracing GC）
### 3.3.1　分代收集理论（Generational Collection）
弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的

强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡

跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数
### 3.3.2　标记-清除算法（Mark-Sweep）
>标记出所有需要回收的对象，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象

![](/images/read/jvm/3-2.jpg)
执行效率不稳定：标记和清除两个过程的执行效率随对象数量增长而降低

内存空间碎片化：空间碎片太多导致分配较大对象时无法找到足够的连续内存而提前触发另一次垃圾收集
### 3.3.3　标记-复制算法
半区复制（Semispace Copying）：内存按容量划分为大小相等的两块，只使用其中的一块。内存用完了就将存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉
![](/images/read/jvm/3-3.jpg)
- 可用内存缩小为了原来的一半，空间浪费多

Appel式回收：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间
- 逃生门：当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）
### 3.3.4　标记-整理算法（Mark-Compact）
>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

![](/images/read/jvm/3-4.jpg)
## 3.4　HotSpot的算法细节实现
### 3.4.1　根节点枚举
枚举根节点时必须要停顿

不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着对象引用
- HotSpot使用OopMap的数据结构来达到这个目的
### 3.4.2　安全点（Safepoint）
>为了解决引用关系变化的问题，只在“特定的位置”记录OopMap信息

选取标准：是否具有让程序长时间执行的特征,“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等

方案1：抢先式中断（Preemptive Suspension）：把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上

方案2：主动式中断（Voluntary Suspension）：设置一个标志位，各个线程轮询，中断标志为真时在最近的安全点上挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象
  - HotSpot使用内存保护陷阱的方式，当需要暂停用户线程时，虚拟机把内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待
### 3.4.3　安全区域
>指能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的

场景：程序“不执行”的时候(Sleep、Blocked)

执行安全区域的代码时，首先标识进入了安全区域，虚拟机垃圾收集时不必去管安全区域的线程。离开安全区域时，如果虚拟机没有完成根节点枚举，就必须等待可以离开安全区域的信号
### 3.4.4　记忆集（Remembered Set）与卡表（Card Table）
>为解决对象跨代引用所带来的问题，避免把整个老年代加进GC Roots扫描范围  
>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构  
>卡表是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等

记忆集
```c
Class RememberedSet {
  Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];
}
```
- 记录精度
  - 字长精度：每个记录精确到一个机器字长，该字包含跨代指针
  - 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针
  - 卡精度(卡表)：每个记录精确到一块内存区域，该区域内有对象含有跨代指针

卡表
```c
CARD_TABLE [this address >> 9] = 0;
```
- 卡页（Card Page）：字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块

![](/images/read/jvm/3-5.jpg "卡表与卡页对应示意图")
  - 一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描
### 3.4.5　写屏障（Write Barrier）
>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）

伪共享（False Sharing）：现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低
- 解决方案(-XX：+UseCondCardMark)：检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏
```c
if (CARD_TABLE [this address >> 9] != 0)
  CARD_TABLE [this address >> 9] = 0;
```
### 3.4.6　并发的可达性分析
三色标记（Tri-color Marking）
- 白色：表示对象尚未被垃圾收集器访问过。开始的阶段都是白色，结束的阶段代表不可达
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过

![](/images/read/jvm/表3-1.jpg)

对象消失,当以下两个条件同时满足时
1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

- 解决方案(通过写屏障实现)
  - 增量更新（Incremental Update）,破坏条件1：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了
  - 原始快照（Snapshot At The Beginning，SATB）,破坏条件2：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索