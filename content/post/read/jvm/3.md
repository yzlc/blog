---
title: "第3章　垃圾收集器与内存分配策略"
date: 2020-05-09T10:32:33+08:00
tags: [jvm]
categories: [阅读]
draft: false
hiddenFromHomePage: true
---

## 3.2　对象已死？
### 3.2.1　引用计数算法
>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
### 3.2.2　可达性分析算法
>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的
![](/images/read/jvm/3-1.jpg)
- GC Roots
  - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
  - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
  - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
  - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
  - 所有被同步锁（synchronized关键字）持有的对象。
  - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
### 3.2.3　再谈引用
- 强引用（Strongly Re-ference）: 指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用（Soft Reference）: 还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常
- 弱引用（Weak Reference）: 非必须对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- 虚引用（Phantom Reference）: 最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
### 3.2.4　生存还是死亡？
可达性分析 -> 标记 -> F-Queue队列,由Finalizer线程执行finalize() -> 标记 -> 回收
### 3.2.5　回收方法区
>废弃的常量和不再使用的类型
- 废弃常量: 回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

- 不再使用的类型
  - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
  - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

- HotSpot虚拟机提供了-Xnoclassgc参数进行控制
- 查看类加载和卸载信息
  - Product版: -verbose：class和-XX：+TraceClassLoading
  - FastDebug版: -XX：+TraceClassUnLoading
- 场景: 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 3.3　垃圾收集算法
>引用计数式垃圾收集（ReferenceCounting GC）和追踪式垃圾收集（Tracing GC）
### 3.3.1　分代收集理论（Generational Collection）
>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。  
2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。  
3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极
少数。
### 3.3.2　标记-清除算法（Mark-Sweep）
>标记出所有需要回收的对象，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象
- 执行效率不稳定: 标记和清除两个过程的执行效率都随对象数量增长而降低
- 内存空间碎片化: 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
![](/images/read/jvm/3-2.jpg)
### 3.3.3　标记-复制算法
- 半区复制（Semispace Copying），将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![](/images/read/jvm/3-3.jpg)
  - 可用内存缩小为了原来的一半，空间浪费多
- Appel式回收: 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间
  - 逃生门: 当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）
### 3.3.4　标记-整理算法（Mark-Compact）
>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存
![](/images/read/jvm/3-4.jpg)
## 3.4　HotSpot的算法细节实现
### 3.4.1　根节点枚举
- 枚举根节点时必须要停顿
- 不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着对象引用
  - HotSpot使用OopMap的数据结构来达到这个目的
### 3.4.2　安全点（Safepoint）
- 选取标准:是否具有让程序长时间执行的特征,“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转
等
- [ ] 方案1:抢先式中断（Preemptive Suspension）:
把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。
- [x] 方案2:主动式中断（Voluntary Suspension）:
设置一个标志位，各个线程轮询，中断标志为真时在最近的安全点上挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他
需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。
  - HotSpot使用内存保护陷阱的方式，当需要暂停用户线程时，虚拟机把内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待
### 3.4.3　安全区域
>指能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的
- 场景:程序“不执行”的时候(Sleep、Blocked)
- 当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全
区域时，它要检查虚拟机是否已经完成了根节点枚举，如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。
### 3.4.4　记忆集（Remembered Set）与卡表（Card Table）
>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。  
>卡表是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等
- 记忆集简单实现
  ```c
  Class RememberedSet {
    Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];
  }
  ```
- 记录精度
  - 字长精度：每个记录精确到一个机器字长，该字包含跨代指针。
  - 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
  - 卡精度(卡表)：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
- 卡表简单实现
  ```c
  CARD_TABLE [this address >> 9] = 0;
  ```
- 卡页（Card Page）: 字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块
![](/images/read/jvm/3-5.jpg)
- 一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。
### 3.4.5　写屏障（Write Barrier）
>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切
面 ，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）
- 伪共享（False Sharing）:现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低
  - 解决方案(-XX：+UseCondCardMark): 检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏
    ```c
    if (CARD_TABLE [this address >> 9] != 0)
      CARD_TABLE [this address >> 9] = 0;
    ```
### 3.4.6　并发的可达性分析
- 三色标记（Tri-color Marking）
  - 白色：表示对象尚未被垃圾收集器访问过。开始的阶段都是白色，结束的阶段代表不可达。
  - 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
  - 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。
![](/images/read/jvm/表3-1.jpg)
- 对象消失,当以下两个条件同时满足时
  1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
  2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

- 解决方案(通过写屏障实现)
  - 增量更新（Incremental Update）,破坏条件1: 当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
  - 原始快照（Snapshot At The Beginning，SATB）,破坏条件2: 当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。
## 3.5　经典垃圾收集器
### 3.5.1　Serial收集器
>单线程,HotSpot虚拟机运行在客户端模式下的默认新生代收集器，对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的,微服务
![](/images/read/jvm/3-7.jpg)
### 3.5.2　ParNew收集器
>Serial收集器的多线程并行版本,除了Serial收集器外，目前只有它能与CMS收集器配合工作
![](/images/read/jvm/3-8.jpg)
### 3.5.3　Parallel Scavenge收集器
>吞吐量优先收集器
- 吞吐量（Throughput）:处理器用于运行用户代码的时间/处理器总消耗时间
- 参数-XX：
  - MaxGCPauseMillis: 最大垃圾收集停顿时间,ms
  - GCTimeRatio: 吞吐量大小,{1/(1+x),默认x=99}
  - +UseAdaptiveSizePolicy: 自适应的调节策略（GC Ergonomics）
### 3.5.4　Serial Old收集器
>Serial收集器的老年代版本
![](/images/read/jvm/3-9.jpg)
### 3.5.5　Parallel Old收集器
>Parallel Scavenge收集器的老年代版本
![](/images/read/jvm/3-10.jpg)
### 3.5.6　CMS收集器（Concurrent Mark Sweep）
>以获取最短回收停顿时间为目标的收集器,B/S系统
![](/images/read/jvm/3-11.jpg)
### 3.5.7　Garbage First收集器(G1)
>使用Region划分内存空间，以及具有优先级的区域回收方式
- 停顿时间模型（Pause Prediction Model）: 在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒
- Mixed GC: 面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大
- Region堆内存布局: 把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理.Humongous区域: 专门用来存储大对象
![](/images/read/jvm/3-13.jpg)
## 3.6　低延迟垃圾收集器
### 3.6.1　Shenandoah收集器
- 并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
- 并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。
- 并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，时间长短取决于内存中涉及的引用数量的多少。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
- Brooks Pointers: 在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己
  - 每次对象访问会带来一次额外的转向开销
  - 并发写入: 通过比较并交换（Compare And Swap，CAS）操作来保证并发时对象的访问正确性
  - 执行频率的问题:通过对象头上的Brooks Pointer来保证并发时原对象与复制对象的访问一致性，要覆盖全部对象访问操作，Shenandoah不得不同时设置读、写屏障去拦截。
    - 引用访问屏障（Load Reference Barrier）: 只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗
### 3.6.2　ZGC收集器(Z Garbage Collector)
>基于Region内存布局，（暂时）不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法，低延迟为目标
- Region: 具有动态性——动态创建和销毁，以及动态的区域容量大小。
  - 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
  - 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。
  - 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。
- 染色指针技术（Colored Pointer）: 把标记信息记在引用对象的指针上，这时，与其说可达性分析是遍历对象
图来标记对象，还不如说是遍历“引用图”来标记“引用”了。
  ![](/images/read/jvm/3-20.jpg)

![](/images/read/jvm/3-22.jpg)
- 并发标记（Concurrent Mark）：标记阶段会更新染色指针中的Marked 0、Marked 1标志
位。
- 并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）
- 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。
  - 指针的自愈（Self-Healing）: 得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象
    - 只有第一次访问旧对象会陷入转发，也就是只慢一次，对比Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢
    - 由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。
- 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图 的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。