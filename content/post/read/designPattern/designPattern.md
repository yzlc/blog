---
title: "设计模式"
date: 2019-07-15T10:32:28+08:00
tags: [设计模式]
categories: [阅读]
draft: false
hiddenFromHomePage: true
---

## 面向对象
### 好处
- 可复用，可扩展，灵活性好
- 通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，并且易于复用
### 内聚性与耦合性
- 内聚性 描述的是一个例程内部组成部分之间相互联系的紧密程度
- 高内聚 内部完整
- 耦合性 描述的是一个例程与其他例程之间联系的紧密程度
- 松耦合 与其他例程之间的联系是小巧、直接、可见、灵活的
## uml类图
>关系所表现的强弱程度依次为：组合>聚合>关联>依赖

![](/images/read/designPattern/uml.png)
- 依赖 弱使用关系，表现在代码层面：类B作为参数被类A在某个method方法中使用
- 关联 平等长期的依赖关系，表现在代码层面：类属性形式
- 聚合 表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分
- 组合 是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样

## 原则
### 单一职责
>就一个类而言，应该仅有一个引起它变化的原因
### 开放-封闭
>软件实体（类、模块、函数等等）应该可以扩展，但是不可修改
### 依赖倒转
>A. 高层模块不应该依赖低层模块。两个都应该依赖抽象  
B. 抽象不应该依赖细节。细节应该依赖抽象
### 里氏代换
>子类型必须能够替换掉它们的父类型
### 迪米特法则
>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
### 合成/聚合复用原则
>尽量使用合成/聚合，尽量不要使用类继承

## 总结
### 创建型模式
>抽象工厂、建造者、工厂方法、原型、单例
- 通常设计应该从工厂方法开始，当需要更大的灵活性时，便向其他创建型模式演化
- 隐藏了类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性
- 抽象了实例化的过程。帮助一个系统独立于如何创建、组合和表示它们的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定
### 结构型模式
>适配器、桥接、组合、装饰、外观、享元、代理
### 行为型模式
>观察者、模板方法、命令、状态、职责链  
解释器、中介者、访问者、策略、备忘录、迭代器