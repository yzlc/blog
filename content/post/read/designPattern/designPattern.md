---
title: "设计模式"
date: 2019-07-15T10:32:28+08:00
tags: [设计模式]
categories: [阅读]
hiddenFromHomePage: true
---

## 面向对象
- 可维护、可复用、可扩展、灵活性好
- 通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，并且易于复用
## 类图
![](/images/read/designPattern/uml.png)
- 依赖：弱使用关系（方法参数）
- 关联：一个类‘知道’另一个类（类属性）
- 聚合：弱‘拥有’关系，A对象可以包含B对象，但B对象不是A对象的一部分（类集合属性）
- 组合：强‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样（构造方法实例化）

强弱程度：组合 > 聚合 > 关联 > 依赖
## 原则
- 单一职责：就一个类而言，应该仅有一个引起它变化的原因
- 开放-封闭：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改
- 依赖倒转：
  - 高层模块不应该依赖低层模块。两个都应该依赖抽象
  - 抽象不应该依赖细节。细节应该依赖抽象
- 里氏代换：子类型必须能够替换掉它们的父类型
- 迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
- 合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承

## 总结
### 创建型模式
>抽象工厂、建造者、工厂方法、原型、单例
- 隐藏了类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性
- 抽象了实例化的过程。帮助一个系统独立于如何创建、组合和表示它们的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定
- 通常设计应该从工厂方法开始，当需要更大的灵活性时，便向其他创建型模式演化
### 结构型模式
>怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。适配器、桥接、组合、装饰、外观、享元、代理
### 行为型模式
>观察者、模板方法、命令、状态、职责链、解释器、中介者、访问者、策略、备忘录、迭代器

行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式